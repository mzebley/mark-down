# mark↓ Core Runtime
*(published as `@mzebley/mark-down`)*

This package provides the framework-agnostic `SnippetClient` and supporting types used to fetch, cache, and render Markdown snippets at runtime. For a monorepo overview visit the [root README](../../README.md).

## Table of contents

1. [Installation](#installation)
2. [Quick start](#quick-start)
3. [Client options](#client-options)
4. [Working with snippets](#working-with-snippets)
5. [SSR and custom fetchers](#ssr-and-custom-fetchers)
6. [Static sites / CDN usage](#static-sites--cdn-usage)
7. [Testing & type safety](#testing--type-safety)
8. [Related packages](#related-packages)
9. [Roadmap](#roadmap)

## Installation

Install the runtime alongside your application code:

```bash
npm install @mzebley/mark-down
```

You will also need a manifest file generated by the CLI. See the [CLI documentation](../cli/README.md) for steps to build `snippets-index.json`.

## Quick start

```ts
import { SnippetClient } from "@mzebley/mark-down";

const client = new SnippetClient({
  manifest: "/snippets-index.json",
});

const hero = await client.get("getting-started-welcome");
const components = await client.listByType("component");

console.log(hero?.title);
```

The client lazily loads the manifest when first needed, then fetches Markdown files on demand. Results are cached for the lifetime of the client instance.

## Client options

`SnippetClient` accepts a single configuration object:

- **`manifest`** (`string | ManifestEntry[] | () => Promise<ManifestEntry[]>`) – where to load the manifest. Pass a URL (default), an in-memory array, or an async factory for advanced scenarios.
- **`fetcher`** (`(input, init) => Promise<Response>`) – provide a custom fetch implementation. Useful for SSR environments or when using libraries like Axios.
- **`markdownRenderer`** – a `(markdown: string) => string | Promise<string>` function. Override to swap the default `marked` renderer for something like `remark` or a bespoke pipeline.
- **`resolveSnippetPath`** – map manifest entries to final URLs. Override when static assets live in a CDN or custom folder.

All options are optional except `manifest`.

## Working with snippets

Commonly used APIs:

- `client.get(slug)` – fetch a single snippet. Returns `Promise<Snippet | undefined>`.
- `client.list(filterOrOptions)` – list snippets using predicates, offsets, and limits.
- `client.listByType(type, options?)` – filter by `type`.
- `client.listByGroup(group, options?)` – filter based on the folder-derived `group`.

Metadata is preserved exactly as declared in front matter. Standard keys (`slug`, `title`, etc.) are copied onto `SnippetMeta` and everything else is available through the `extra` bag so you can access custom fields like `snippet.extra.ctaLabel`.

## SSR and custom fetchers

The runtime runs in browsers, Node.js, or edge runtimes. For server-side rendering:

```ts
import fetch from "node-fetch";
import { SnippetClient } from "@mzebley/mark-down";

const client = new SnippetClient({
  manifest: () => import("./snippets-index.json"),
  fetcher: (input, init) => fetch(input as string, init),
});
```

You can also pre-seed snippets by passing an array to `manifest` to avoid network requests entirely.

## Static sites / CDN usage

Need to run mark↓ inside a plain `<script type="module">` context? Use the pre-bundled browser build published at `dist/browser.js`. It automatically polyfills the minimum `Buffer` APIs required by the runtime.

```html
<script type="module">
  import { SnippetClient } from "https://cdn.jsdelivr.net/npm/@mzebley/mark-down/dist/browser.js";

  const client = new SnippetClient({ manifest: "./snippets-index.json" });
  const hero = await client.get("marketing-hero");
  document.querySelector("#hero").innerHTML = hero.html;
</script>
```

As long as you host `snippets-index.json` (generated by the CLI) alongside your static assets, this bundle works without any additional tooling or manual Buffer shims.

## Testing & type safety

- Use `SnippetMeta` and `Snippet` TypeScript types to describe props and state in your application.
- Mock the client by providing a manifest array or by stubbing the `fetcher` function.
- Run the workspace tests with `npm run test -- core` to exercise Vitest suites that cover caching, filtering, and Markdown conversion.

## Related packages

- [CLI](../cli/README.md) – generate and watch manifests during development.
- [Angular adapter](../angular/README.md) – DI-aware provider, service, and component abstractions.
- [React adapter](../react/README.md) – Hooks and components for React and Next.js applications.

Looking for a step-by-step walkthrough? Start from the [Quick start guide in the root README](../../README.md#quick-start).

## Roadmap

- **Tag-aware helpers** – add `listByTag` and `listByExtra` filters for common metadata structures.
- **Prefetch & hydration APIs** – expose utilities for bundling snippets with static builds or preloading ahead of navigation.
- **Search integration** – optional fuzzy search index built from manifest data.
- **Cache policies** – allow LRU or time-based eviction strategies to better suit long-lived sessions.
