# mark↓ Core Runtime
*(published as `@mzebley/mark-down`)*

This package provides the framework-agnostic `SnippetClient` and supporting types used to fetch, cache, and render Markdown snippets at runtime. For a monorepo overview visit the [root README](../../README.md).

## Table of contents

1. [Installation](#installation)
2. [Quick start](#quick-start)
3. [Client options](#client-options)
4. [Working with snippets](#working-with-snippets)
5. [SSR and custom fetch functions](#ssr-and-custom-fetch-functions)
6. [Static sites / CDN usage](#static-sites--cdn-usage)
7. [Testing & type safety](#testing--type-safety)
8. [Related packages](#related-packages)
9. [Roadmap](#roadmap)

## Installation

Install the runtime alongside your application code:

```bash
npm install @mzebley/mark-down
```

You will also need a manifest file generated by the CLI. See the [CLI documentation](../cli/README.md) for steps to build `snippets-index.json`.

## Quick start

```ts
import { SnippetClient } from "@mzebley/mark-down";

const client = new SnippetClient({
  manifest: "/snippets-index.json",
});

const hero = await client.get("getting-started-welcome");
const components = await client.listByType("component");

console.log(hero.title);
```

The client lazily loads the manifest when first needed, then fetches Markdown files on demand. Results are cached for the lifetime of the client instance.

## Client options

`SnippetClient` accepts a single configuration object:

- **`manifest`** (`string | SnippetMeta[] | () => Promise<SnippetMeta[]>`) – where to load the manifest. Provide a URL, an in-memory array, or an async factory.
- **`base`** (`string`) – optional base path prepended to relative snippet paths. The client infers the directory from the manifest URL when omitted.
- **`fetch`** (`(url: string) => Promise<Response | string>`) – inject a custom fetch implementation. Use this for SSR, testing, or advanced caching.
- **`frontMatter`** (`boolean`, default `true`) – toggle YAML front-matter parsing.
- **`cache`** (`boolean`, default `true`) – enable or disable per-snippet and manifest memoisation.
- **`verbose`** (`boolean`) – log helpful warnings (for example, slug mismatches) during development.
- **`render`** (`(markdown: string) => string | Promise<string>`) – override the default `marked` renderer when you need custom HTML output.

All options are optional except `manifest`. Results are rendered with `marked` by default; override at the application level if you need a different Markdown pipeline.

## Working with snippets

Commonly used APIs:

- `client.get(slug)` – fetch a single snippet. Throws `SnippetNotFoundError` if the manifest does not include the slug.
- `client.listAll()` – return a copy of every manifest entry.
- `client.listByType(type)` / `client.listByGroup(group)` – targeted manifest filters.
- `client.search({ type, group, tags, tagsMode })` – multi-field search helper with tag matching.
- `client.getHtml(slug)` – convenience wrapper that resolves directly to HTML.
- `client.invalidate()` / `client.invalidateSlug(slug)` – clear caches to force refetching.

Metadata is preserved exactly as declared in front matter. Standard keys (`slug`, `title`, etc.) are copied onto `SnippetMeta`, additional properties live inside `extra`, and the resolved `Snippet` includes both rendered HTML and an optional `raw` Markdown string (without front matter) for advanced use cases.

## SSR and custom fetch functions

The runtime runs in browsers, Node.js, or edge runtimes. For server-side rendering:

```ts
import fetch from "node-fetch";
import { SnippetClient } from "@mzebley/mark-down";

const client = new SnippetClient({
  manifest: () => import("./snippets-index.json"),
  fetch: (url) => fetch(url).then((response) => {
    if (!response.ok) {
      throw new Error(`Request failed with status ${response.status}`);
    }
    return response;
  }),
});
```

You can also pre-seed snippets by passing an array to `manifest` to avoid network requests entirely. When `cache` is disabled the client re-fetches both manifest and snippet payloads on every request.

## Static sites / CDN usage

Need to run mark↓ inside a plain `<script type="module">` context? Use the pre-bundled browser build published at `dist/browser.js`. It automatically polyfills the minimum `Buffer` APIs required by the runtime.

```html
<script type="module">
  import { SnippetClient } from "https://cdn.jsdelivr.net/npm/@mzebley/mark-down/dist/browser.js";

  const client = new SnippetClient({ manifest: "./snippets-index.json" });
  const hero = await client.get("marketing-hero");
  document.querySelector("#hero").innerHTML = hero.html;
</script>
```

As long as you host `snippets-index.json` (generated by the CLI) alongside your static assets, this bundle works without any additional tooling or manual Buffer shims.

## Testing & type safety

- Use `SnippetMeta` and `Snippet` TypeScript types to describe props and state in your application.
- Mock the client by providing a manifest array or by stubbing the `fetch` option.
- Run the workspace tests with `npm run test -- core` to exercise Vitest suites that cover caching, filtering, and Markdown conversion.

## Related packages

- [CLI](../cli/README.md) – generate and watch manifests during development.
- [Angular adapter](../angular/README.md) – DI-aware provider, service, and component abstractions.
- [React adapter](../react/README.md) – Hooks and components for React and Next.js applications.

Looking for a step-by-step walkthrough? Start from the [Quick start guide in the root README](../../README.md#quick-start).

## Roadmap

- **Tag-aware helpers** – add `listByTag` and `listByExtra` filters for common metadata structures.
- **Prefetch & hydration APIs** – expose utilities for bundling snippets with static builds or preloading ahead of navigation.
- **Search integration** – optional fuzzy search index built from manifest data.
- **Cache policies** – allow LRU or time-based eviction strategies to better suit long-lived sessions.
